#class implicit_functions super prototype implicit_return

compiles:
class UI {
  
}

to:
function UI() {

}


compiles:
class UI(x, y) {
  x = 1
}

to:
function UI(x, y) {
  x = 1
}

compiles:
class UI(x, y) extends Parent {
  x = 1
}

to:
function UI(x, y)  {
  Parent.apply(this, arguments); x = 1
}
__extends(UI, Parent)

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}

compiles:

class UI(x, y) extends X {
  super(x, y)
}

to:
function UI(x, y)  {
  X.call(this, x, y)
}
__extends(UI, X)

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}




compiles:
class UI(x, y) extends Parent {
  x = 1
}

to:
function UI(x, y)  {
  Parent.apply(this, arguments); x = 1
}
__extends(UI, Parent)

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}

compiles:


UI#render = {
  super()
}

to:

UI.prototype.render = function() {
  return this.__super__.render.call(this)
}

UI#render = {
  super
}

to:

UI.prototype.render = function() {
  return this.__super__.render.apply(this, arguments)
}



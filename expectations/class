#class implicit_functions super prototype implicit_return

compiles:
class UI {
  
}

to:
function UI() {

};

compiles:
class UI(x, y) {
  x = 1
}

to:
function UI(x, y) {
  x = 1
}; 

compiles:
class UI(x, y) extends Parent {
  x = 1
}; 

to:
function UI(x, y)  {
  x = 1
}; __extends(UI, Parent);  

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent;
  child.prototype.__super__ = parent.prototype;
  return child;
}

compiles:

class UI(x, y) extends X {
  super(x, y)
};

to:
function UI(x, y)  {
  this.constructor.__super__.call(this, x, y)
}; __extends(UI, X);  

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent;
  child.prototype.__super__ = parent.prototype;
  return child;
}




compiles:
class UI(x, y) extends Parent {
  x = 1
}

to:
function UI(x, y)  {
  x = 1
}; __extends(UI, Parent); 

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent;
  child.prototype.__super__ = parent.prototype;
  return child;
}

compiles:

UI::render = {
  super()
}

to:

UI.prototype.render = function() {
  return this.__super__.render.call(this)
}

compiles:

UI::render = {
  super
}

to:

UI.prototype.render = function() {
  return this.__super__.render.apply(this, arguments)
}

compiles:

class Z(key) {
  @head = null
  @key = key
}

to:

function Z(key) {
  @head = null
  @key = key
}; 

compiles:
class Z

to:
function Z(){;}; 


compiles:
class Z; class A

to:
function Z(){;}; function A(){;};

compiles:

class Z extends Y

to:

function Z(){ this.constructor.__super__.apply(this, arguments);}; __extends(Z, Y);

function __extends(child, parent) {
  var __hasProp = Object.prototype.hasOwnProperty;
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent;
  child.prototype.__super__ = parent.prototype;
  return child;
}



h3 Unwrapping async calls with ! (bang)

p A ! postfix to a function call signals to Kaffeine that this is an unwrapped async call masquerading as a normal function call. Kaffeine will recompile it into a normal function call with the follow code wrapping into an async callback.

h3 Example

textarea
  // simple call
  fish = $.get! '/fish'     
  $("stomach").append fish

  // another simple call with implied ()
  ok = stomach.save!        
  meal.complete = ok

  This is super useful for simplifying nested asynchronous calls (esp with nodejs) and works nicely in a number of scenarios:

  // create convenient sleep function
  sleep = -> { setTimeout #1, #0 }

  // use it
  test_check = -> {
    if !@chess.isCheck() {
      sleep! 400
      alert "STALEMATE"
    }
  }
  
p When does the function unwrapping ‘stop’?

ul
  li At an unmatched right bracket (e.g. the end of a function or arg list)
  li The end of the file
  li Or the —– operator – added for completeness, but I have never actually needed it


textarea
  x = -> {
    result = shoot! user1
    if result, user1.die!
    ---
    result = shoot! user2
    if result, user.die!
    ---
    result = shoot! user3
    if result, user.die!
    ---
  }

h3 @ in bang function calls

p In the case of unwrapped async calls via the bang postfix, @ will actually refer to the outer this.
p Since we can refer to both via this method, binding becomes unnecessary.

h4 Example

textarea
  Class.cacheData = -> {
    d = $.get! "/" 
    @data = d      // outer this
    this.data = d  // inner this
    return @
  }

h4 Implicit variable declaration

p This module provides support for omitting the var keyword: the variables will be automagically defined in the closest relevant closure.

h4 Examples

textarea
  x = 1, a = 3
  -> {
    x = 2
    y = 2
  }

p The var will be pulled to the top of the current closure:
textarea
  -> {
    x = 2
    var x
  }

h3 Explicit assigment. 

p It’s possible to explicity declare a variable to a function scope if you don’t want to trample over a variable in outer scope:

textarea
  state = "running"
  run = ->
    var state = {}
  run()

h3 for loop extensions

p This module adds additional functionality to the for loop:
p of operator for looping through arrays. The first parameter will refer to the element itself, and an optional 2nd paramter will refer to the index:
textarea

  A = [7,3,4]

  // will log 14
  for x of A
    sum += x
  log sum     

  // will log 3
  for x, i of A
    sum += i
  log sum

p Kaffeine also provides a second optional second parameter for the in keyword, containing the value:

textarea
  A = [7,3,4]
  z = ""

  // will log 734
  for key, val in A
    zip += val


h3 Leaving off the brackets!

p Kaffeine provides support for optional Brackets In Function Calls

textarea
  remove eggs.shell
  mix eggs, milk.off ? milk : null
  outer inner innermost

p Optional Brackets For Keywords

p keywords such as for and if can omit their brackets (as long as the statement does not become amiguous). The brackets are inserted either before a newline, a left brace ‘{’ or a comma (for one liners)

textarea
  // for
  for i in A
    run A[i]

  // if
  if name == "john", return false

  // while
  while we_have_time { 
    run tasks 
  }


h3 Interpolated strings and multiline

p Kaffeine supports interpolation in the strings via the \#{} operator

textarea
  "my name is \\#{Rohan}"

p Interpolation can be sutextareassed by a backslace, e.g. <code>"\#{xx}"</code>

p ... also supports multiline text

textarea
  a = "English breakfast:
  * eggs
  * bacon
  * sausages"

p Kaffeine inserts newlines here to make the text output as it looks, but to prohibit the extra newlines - use the normal JavaScript backslash: 

textarea
  a = "English breakfast:\
  * eggs\
  * bacon\
  * sausages"




h2 Function extensions

h3 arrow function alias

p Kaffeine supports a simple arrow as an alias to a function call. 
textarea 
  ok = (timeout) -> {
    sendNote()  
  }

p Braces are optional for one liners and also an empty argument list can be omitted

textarea
  run = -> ok(0)


h3 Binding arrow =>


p In complex scripts, managing the value of this can become an issue. Kaffeine includes a convenience utility for binding an arrow function to the scope it is created in. 

p A common pattern in JavaScript is running a function in the current scope of this. Kaffeine has support for this through the fat arrow => 

textarea
  $(".heading").click => @remove()

p The underlying binding operation is performed by a helper function called __bind which is appended to the end of the program (won't interfere with line numbering).

h3 Implicit return

p Usually, the completion value of a function is undefined, unless you explicitly return something different. Kaffeine's arrow function syntax juices up the function-calling process by determining a completion value based on the last statement in the block, and returning that automatically.

h4  What's the advantage?
p Completion value return helps promote the writing of functions that operate on and return data, rather than simply being there to produce side-effects. This is a core aspect of the functional programming style, but it also has benefits for object-oriented designs as well.

p The last statement of a function will be automagically returned (Ruby style). For example

textarea
  getName = -> @name

p This will only work for returnable statements, i.e. variables, objects and functions. So an final if statement will result no return value

textarea
  getName = -> { 
    if truthy 
      @name 
  }

p Note: this will be added in a future version. See Roadmap

h4 Gotcha: don't use function arrow syntax for constructors

p A constructor function won't work properly if it returns an array or an object. To avoid mistakenly creating a dud constructor, you can either fall back to using the function keyword, or opt-in to Kaffeine's class keyword, which offers enhanced inheritance support.

Default arguments

p This feaure allows support for ruby-syle defaults for null or undefined arguments. Note, this uses non strict comparison with null, meaning falsy values such as 0 or "" can be used as defaults.

textarea
  fn = (x=1, a=0) -> {
    log x, a
  }
  fn 5  // => 5, 0

h4 Classes 

p Kaffeine provides support for simple class inheritence, super and friends

h3 :: Operator

p :: provides a shortcut to the prototype. For brevity, the :: operator on its own will reference the most recently assigned function:

textarea 
  Animal = -> {}
  ::fast = -> { return this.speed > 100 }
  ::alive = true

h3 Hash Alias
p Kaffeine provides # shortcut for referring to the first argument in a function. Useful for terse function definitions:

textarea 
  square = -> #*# 

p Additionally, #n refers to the nth argument (n >= 0).
textarea
  times = -> #*#1 

h3 .= (dot equals) and ||= (OR equals)

p 2 extra assignment operators, ||= and .=. They work in a similar method as += etc.

textarea
  location.href .= replace "?old", "?new"
  name .= toUpperCase()
  opts ||= {}

h3 Unix-style function calling via | (pipe)

p This is probably one of the most unusual features of Kaffeine. It provides an alternative calling method than can be used for chaining (UNIX style passing).
p It also automatically loads a stdlib utility pipe_utils by default.

h4 Examples
textarea 
  result = input | fn args

p Chaining Input To Output

textarea
  result = input | fn a, b | fn2 c | fn3 d

p For example, it is very useful for ruby style enumeration chaining without using prototypes, and other utilities

textarea
  People | map -> { #.name } | detect -> #.length > 3
  opts = opts | extend default
  5 | times { if(!send()) return false }
  names | asyncMap (name, fn) -> {
    user = User.find! {name: name}
    fn(user)
  }, complete

h3 pipe_utils stdlib 

p Kaffeine also by default provides a stdlib style package called pipe_utils which will automatically be required, containing useful Enumeration functions such as map and keys etc.

h3 Ruby-style symbols

p Ruby style symbols get converted to strings. Symbols are useful for easily observing which values are _state_ and which are output such as HTML or logging. They don’t share Ruby’s immutabilty (i.e. you can still perform string operations on them).

textarea
  if state is :end {
    state = :start
    run()
  }

h3 English comparison operators

p The english words is, or, not, and, isnt are converted to the keywords ===, ||, !, && !== respecively.

p Note that the conversion will not occur if they occur next to an operator, meaning that these keywords can still be used as variable identifiers, although it's not recommended. For examples, you can still write:

textarea
  if x is 100 or y isnt run(), return
  is = require "assert"
  
h3 Using keyword

p The using keyword imports functions from an object into the current scope. For example if we have a library called "ninja" which exposes two methods jump and kick.

textarea
  using * from require "ninja"
  jump "high"
  kick()

p If we only wanted to import jump, we could write: 

textarea 
  using jump from require "ninja"
  jump "high"

p Note: that the * form uses eval, so it won’t work with ES5 strict, and also be careful putting it in sections of code that are often called.

h3 Block scope

p Kaffeine provides support for block scope (Harmony-style) via closures

textarea
  x = 100
  pairs = {
    var x = "a:b"
    x.split ":"
  }

h4 caveat
p Since this feature uses a closure, you cannot return from the outer scope from within the block. I.e

textarea
  test = -> {
    { return 100 }
    200
  }
  // test() will return 200


h3 Installation


h3 Use

h2 Ideas going forward

h3 Array comtextareahensions 

textarea 
  x = for y of myArray {
        if y > 10, break 
        x += y
      }

h3 auto-slice arguments
  
p Within any function, a reference to arguments will be auto-converted to a sliced version (meaning it can be used as a proper array object).

h3 Existential ? operator

p extend implicit return through if blocks

